{"ast":null,"code":"import React, { useEffect, useMemo, useRef, useState } from 'react';\nimport { useLayoutEffect } from '../../utils/use-isomorphic-layout-effect';\nimport { findScrollParent, findScrollParents, isNodeAfterScroll, isNodeBeforeScroll } from '../../utils';\nimport { Box } from '../Box';\nimport { InfiniteScrollPropTypes } from './propTypes';\n\nvar calculateLastPageBound = function calculateLastPageBound(show, step) {\n  return show ? Math.floor((show + step) / step) - 1 : 0;\n};\n\nvar InfiniteScroll = function InfiniteScroll(_ref) {\n  var children = _ref.children,\n      _ref$items = _ref.items,\n      items = _ref$items === void 0 ? [] : _ref$items,\n      onMore = _ref.onMore,\n      renderMarker = _ref.renderMarker,\n      replace = _ref.replace,\n      show = _ref.show,\n      _ref$step = _ref.step,\n      step = _ref$step === void 0 ? 50 : _ref$step; // item index to be made visible initially\n\n  var _useState = useState(),\n      scrollShow = _useState[0],\n      setScrollShow = _useState[1]; // the last page we have items for\n\n\n  var lastPage = useMemo(function () {\n    return Math.max(0, Math.ceil(items.length / step) - 1);\n  }, [items.length, step]); // the pages we are rendering\n\n  var _useState2 = useState([0, calculateLastPageBound(show, step)]),\n      renderPageBounds = _useState2[0],\n      setRenderPageBounds = _useState2[1]; // the heights of the pages, approximated after we render the first page\n  // and then updated for pages that have rendered\n\n\n  var _useState3 = useState([]),\n      pageHeights = _useState3[0],\n      setPageHeights = _useState3[1]; // what we're waiting for onMore to give us\n\n\n  var _useState4 = useState(0),\n      pendingLength = _useState4[0],\n      setPendingLength = _useState4[1];\n\n  var aboveMarkerRef = useRef(); // only when replacing\n\n  var belowMarkerRef = useRef(); // scroll and resize handling\n\n  useEffect(function () {\n    var scrollParents;\n\n    var evaluate = function evaluate() {\n      if (!scrollParents) return;\n      var scrollParent = scrollParents[0]; // Determine the scroll position of the scroll container\n\n      var top;\n      var height;\n\n      if (scrollParent === document) {\n        top = document.documentElement.scrollTop || document.body.scrollTop;\n        height = window.innerHeight;\n      } else {\n        top = scrollParent.scrollTop;\n        var rect = scrollParent.getBoundingClientRect();\n        height = rect.height;\n      }\n\n      var offset = height / 4; // so we pre-load when the user scrolls slowly\n      // Use the pageHeights to determine what pages we should render based\n      // on the current scroll window.\n\n      var nextBeginPage = 0;\n      var index = 0;\n      var pagesHeight = pageHeights[index] || 0;\n\n      while (pageHeights[index + 1] && pagesHeight < top - offset) {\n        index += 1;\n        nextBeginPage += 1;\n        pagesHeight += pageHeights[index];\n      }\n\n      var nextEndPage = nextBeginPage;\n\n      while (pageHeights[index] !== undefined && pagesHeight < top + height + offset) {\n        index += 1;\n        nextEndPage += 1; // when we haven't rendered the nextEndPage and we aren't replacing,\n        // we might not have a height for it yet\n\n        pagesHeight += pageHeights[index] || 0;\n      }\n\n      if (!replace) {\n        // when not replacing, never shrink bounds\n        nextBeginPage = 0;\n        nextEndPage = Math.max(renderPageBounds[1], nextEndPage);\n      }\n\n      if (show) {\n        // ensure we try to render any show page\n        var showPage = calculateLastPageBound(show, step);\n        nextBeginPage = Math.min(showPage, nextBeginPage);\n        nextEndPage = Math.max(showPage, nextEndPage);\n      }\n\n      if (nextBeginPage !== renderPageBounds[0] || nextEndPage !== renderPageBounds[1]) {\n        setRenderPageBounds([nextBeginPage, nextEndPage]);\n      }\n    };\n\n    var timer;\n\n    var debounce = function debounce() {\n      clearTimeout(timer);\n      timer = setTimeout(evaluate, 10);\n    }; // might not be there yet or might have already rendered everything\n\n\n    if (belowMarkerRef.current) {\n      scrollParents = findScrollParents(belowMarkerRef.current);\n      scrollParents.forEach(function (sp) {\n        return sp.addEventListener('scroll', debounce);\n      });\n    }\n\n    window.addEventListener('resize', debounce);\n    evaluate();\n    return function () {\n      if (scrollParents) {\n        scrollParents.forEach(function (sp) {\n          return sp.removeEventListener('scroll', debounce);\n        });\n      }\n\n      window.removeEventListener('resize', debounce);\n      clearTimeout(timer);\n    };\n  }, [pageHeights, renderPageBounds, replace, show, step]); // check if we need to ask for more\n\n  useEffect(function () {\n    if (onMore && renderPageBounds[1] === lastPage && items.length >= pendingLength && items.length > 0) {\n      // remember we've asked for more, so we don't keep asking if it takes\n      // a while\n      setPendingLength(items.length + 1);\n      onMore();\n    }\n  }, [items.length, lastPage, onMore, pendingLength, renderPageBounds, step]);\n  useEffect(function () {\n    if (items.length === 0 && lastPage === 0 && pendingLength !== 0) {\n      setPageHeights([]);\n      setPendingLength(0);\n      setRenderPageBounds([0, calculateLastPageBound(show, step)]);\n    }\n  }, [lastPage, pendingLength, show, step, items.length]); // scroll to any 'show'\n\n  useLayoutEffect(function () {\n    // ride out any animation delays, 100ms empirically measured\n    var timer = setTimeout(function () {\n      if (show && belowMarkerRef.current && show !== scrollShow) {\n        // calculate show index based on beginPage\n        var showIndex = show - renderPageBounds[0] * step + (renderPageBounds[0] ? 1 : 0);\n        var showNode = belowMarkerRef.current.parentNode.children.item(showIndex);\n\n        if (showNode) {\n          var scrollParent = findScrollParent(showNode);\n\n          if (isNodeBeforeScroll(showNode, scrollParent)) {\n            showNode.scrollIntoView(true);\n          } else if (isNodeAfterScroll(showNode, scrollParent)) {\n            showNode.scrollIntoView(false);\n          } // clean up after having shown\n\n\n          setScrollShow(show);\n        }\n      }\n    }, 100);\n    return function () {\n      return clearTimeout(timer);\n    }; // Omitting scrollShow as a dependency due to concern that setScrollShow\n    // is being called within the timer. If left included, re-renders and other\n    // dependency values could change in an unpredictable manner during timer\n    // and potentially result in an infinite loop.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [renderPageBounds, show, step]); // calculate and keep track of page heights\n\n  useLayoutEffect(function () {\n    // if don't have a belowMarker, we must have rendered everything already\n    if (!belowMarkerRef.current) return; // calculate page heights for rendered pages\n\n    var rendered = belowMarkerRef.current.parentNode.children; // ensure we've rendered the state we have\n    // above? + items in rendered pages + below === rendered DOM elements length\n\n    if ((aboveMarkerRef.current ? 1 : 0) + (renderPageBounds[1] - renderPageBounds[0] + 1) * step + 1 === rendered.length) {\n      var nextPageHeights; // step through each page\n\n      var i = renderPageBounds[0];\n      var lastBottom;\n\n      while (i <= renderPageBounds[1]) {\n        var topIndex = (aboveMarkerRef.current ? 1 : 0) + (i - renderPageBounds[0]) * step;\n        var bottomIndex = Math.min(topIndex + step - 1, rendered.length - 1); // we use lastBottom for top to ensure grid layouts work\n\n        var top = lastBottom !== undefined ? lastBottom : rendered.item(topIndex).getBoundingClientRect().top;\n\n        var _rendered$item$getBou = rendered.item(bottomIndex).getBoundingClientRect(),\n            bottom = _rendered$item$getBou.bottom;\n\n        var height = bottom - top;\n\n        if (bottom && (!pageHeights || pageHeights[i] !== height)) {\n          if (!nextPageHeights) nextPageHeights = [].concat(pageHeights || []);\n          nextPageHeights[i] = height;\n        }\n\n        lastBottom = bottom;\n        i += 1;\n      } // estimate page heights for pages we haven't rendered yet\n\n\n      while (replace && i <= lastPage) {\n        if (!pageHeights[i] && pageHeights[i] !== pageHeights[0]) {\n          if (!nextPageHeights) nextPageHeights = [].concat(pageHeights || []);\n          var _nextPageHeights = nextPageHeights;\n          nextPageHeights[i] = _nextPageHeights[0];\n        }\n\n        i += 1;\n      }\n\n      if (nextPageHeights) setPageHeights(nextPageHeights);\n    }\n  }, [lastPage, pageHeights, renderPageBounds, replace, step]); // calculate the height above the first rendered page using the pageHeights\n\n  var aboveHeight = useMemo(function () {\n    if (!replace) return 0;\n    var height = 0;\n    var i = 0;\n\n    while (i < renderPageBounds[0]) {\n      height += pageHeights[i] || 0;\n      i += 1;\n    }\n\n    return height;\n  }, [pageHeights, renderPageBounds, replace]); // calculate the height below the last rendered page using the pageHeights\n\n  var belowHeight = useMemo(function () {\n    if (!replace) return 0;\n    var height = 0;\n    var i = renderPageBounds[1] + 1;\n\n    while (i <= lastPage) {\n      height += pageHeights[i] || 0;\n      i += 1;\n    }\n\n    return height;\n  }, [lastPage, pageHeights, renderPageBounds, replace]);\n  var firstIndex = renderPageBounds[0] * step;\n  var lastIndex = Math.min((renderPageBounds[1] + 1) * step, items.length) - 1;\n  var result = [];\n\n  if (aboveHeight) {\n    var marker = /*#__PURE__*/React.createElement(Box, {\n      key: \"above\",\n      ref: aboveMarkerRef,\n      flex: false,\n      height: aboveHeight + \"px\"\n    });\n\n    if (renderMarker) {\n      // need to give it a key\n      marker = /*#__PURE__*/React.cloneElement(renderMarker(marker), {\n        key: 'above'\n      });\n    }\n\n    result.push(marker);\n  }\n\n  items.slice(firstIndex, lastIndex + 1).forEach(function (item, index) {\n    var itemsIndex = firstIndex + index;\n    var child = children(item, itemsIndex);\n    result.push(child);\n  });\n\n  if (replace || renderPageBounds[1] < lastPage || onMore) {\n    var _marker = /*#__PURE__*/React.createElement(Box, {\n      key: \"below\",\n      ref: !renderMarker && belowMarkerRef || undefined,\n      flex: false,\n      height: (belowHeight || 0) + \"px\"\n    });\n\n    if (renderMarker) {\n      // need to give it a key\n      var renderedMarker = renderMarker(_marker);\n      _marker = /*#__PURE__*/React.cloneElement(renderedMarker, {\n        key: 'below',\n        // We need to make sure our belowMarkerRef is tied to a component\n        // that has the same parent as the items being rendered. This is so\n        // we can use belowMarkerRef.current.parentNode.children to\n        // get a reference to the items in the DOM for calculating pageHeights.\n        //\n        // Since the caller might have included a ref in what their\n        // renderMarker returns, we have to take care of both refs.\n        // https://github.com/facebook/react/issues/8873#issuecomment-489579878\n        ref: function ref(node) {\n          // Keep your own reference\n          belowMarkerRef.current = node; // Call the original ref, if any\n\n          var ref = renderedMarker.ref;\n\n          if (typeof ref === 'function') {\n            ref(node);\n          } else if (ref !== null) {\n            ref.current = node;\n          }\n        }\n      });\n    }\n\n    result.push(_marker);\n  }\n\n  return result;\n};\n\nInfiniteScroll.propTypes = InfiniteScrollPropTypes;\nexport { InfiniteScroll };","map":{"version":3,"names":["React","useEffect","useMemo","useRef","useState","useLayoutEffect","findScrollParent","findScrollParents","isNodeAfterScroll","isNodeBeforeScroll","Box","InfiniteScrollPropTypes","calculateLastPageBound","show","step","Math","floor","InfiniteScroll","_ref","children","_ref$items","items","onMore","renderMarker","replace","_ref$step","_useState","scrollShow","setScrollShow","lastPage","max","ceil","length","_useState2","renderPageBounds","setRenderPageBounds","_useState3","pageHeights","setPageHeights","_useState4","pendingLength","setPendingLength","aboveMarkerRef","belowMarkerRef","scrollParents","evaluate","scrollParent","top","height","document","documentElement","scrollTop","body","window","innerHeight","rect","getBoundingClientRect","offset","nextBeginPage","index","pagesHeight","nextEndPage","undefined","showPage","min","timer","debounce","clearTimeout","setTimeout","current","forEach","sp","addEventListener","removeEventListener","showIndex","showNode","parentNode","item","scrollIntoView","rendered","nextPageHeights","i","lastBottom","topIndex","bottomIndex","_rendered$item$getBou","bottom","concat","_nextPageHeights","aboveHeight","belowHeight","firstIndex","lastIndex","result","marker","createElement","key","ref","flex","cloneElement","push","slice","itemsIndex","child","_marker","renderedMarker","node","propTypes"],"sources":["/Users/siddharthkhatri/Developer/React JS/phone-book/client/node_modules/grommet/es6/components/InfiniteScroll/InfiniteScroll.js"],"sourcesContent":["import React, { useEffect, useMemo, useRef, useState } from 'react';\nimport { useLayoutEffect } from '../../utils/use-isomorphic-layout-effect';\nimport { findScrollParent, findScrollParents, isNodeAfterScroll, isNodeBeforeScroll } from '../../utils';\nimport { Box } from '../Box';\nimport { InfiniteScrollPropTypes } from './propTypes';\n\nvar calculateLastPageBound = function calculateLastPageBound(show, step) {\n  return show ? Math.floor((show + step) / step) - 1 : 0;\n};\n\nvar InfiniteScroll = function InfiniteScroll(_ref) {\n  var children = _ref.children,\n      _ref$items = _ref.items,\n      items = _ref$items === void 0 ? [] : _ref$items,\n      onMore = _ref.onMore,\n      renderMarker = _ref.renderMarker,\n      replace = _ref.replace,\n      show = _ref.show,\n      _ref$step = _ref.step,\n      step = _ref$step === void 0 ? 50 : _ref$step;\n\n  // item index to be made visible initially\n  var _useState = useState(),\n      scrollShow = _useState[0],\n      setScrollShow = _useState[1]; // the last page we have items for\n\n\n  var lastPage = useMemo(function () {\n    return Math.max(0, Math.ceil(items.length / step) - 1);\n  }, [items.length, step]); // the pages we are rendering\n\n  var _useState2 = useState([0, calculateLastPageBound(show, step)]),\n      renderPageBounds = _useState2[0],\n      setRenderPageBounds = _useState2[1]; // the heights of the pages, approximated after we render the first page\n  // and then updated for pages that have rendered\n\n\n  var _useState3 = useState([]),\n      pageHeights = _useState3[0],\n      setPageHeights = _useState3[1]; // what we're waiting for onMore to give us\n\n\n  var _useState4 = useState(0),\n      pendingLength = _useState4[0],\n      setPendingLength = _useState4[1];\n\n  var aboveMarkerRef = useRef(); // only when replacing\n\n  var belowMarkerRef = useRef(); // scroll and resize handling\n\n  useEffect(function () {\n    var scrollParents;\n\n    var evaluate = function evaluate() {\n      if (!scrollParents) return;\n      var scrollParent = scrollParents[0]; // Determine the scroll position of the scroll container\n\n      var top;\n      var height;\n\n      if (scrollParent === document) {\n        top = document.documentElement.scrollTop || document.body.scrollTop;\n        height = window.innerHeight;\n      } else {\n        top = scrollParent.scrollTop;\n        var rect = scrollParent.getBoundingClientRect();\n        height = rect.height;\n      }\n\n      var offset = height / 4; // so we pre-load when the user scrolls slowly\n      // Use the pageHeights to determine what pages we should render based\n      // on the current scroll window.\n\n      var nextBeginPage = 0;\n      var index = 0;\n      var pagesHeight = pageHeights[index] || 0;\n\n      while (pageHeights[index + 1] && pagesHeight < top - offset) {\n        index += 1;\n        nextBeginPage += 1;\n        pagesHeight += pageHeights[index];\n      }\n\n      var nextEndPage = nextBeginPage;\n\n      while (pageHeights[index] !== undefined && pagesHeight < top + height + offset) {\n        index += 1;\n        nextEndPage += 1; // when we haven't rendered the nextEndPage and we aren't replacing,\n        // we might not have a height for it yet\n\n        pagesHeight += pageHeights[index] || 0;\n      }\n\n      if (!replace) {\n        // when not replacing, never shrink bounds\n        nextBeginPage = 0;\n        nextEndPage = Math.max(renderPageBounds[1], nextEndPage);\n      }\n\n      if (show) {\n        // ensure we try to render any show page\n        var showPage = calculateLastPageBound(show, step);\n        nextBeginPage = Math.min(showPage, nextBeginPage);\n        nextEndPage = Math.max(showPage, nextEndPage);\n      }\n\n      if (nextBeginPage !== renderPageBounds[0] || nextEndPage !== renderPageBounds[1]) {\n        setRenderPageBounds([nextBeginPage, nextEndPage]);\n      }\n    };\n\n    var timer;\n\n    var debounce = function debounce() {\n      clearTimeout(timer);\n      timer = setTimeout(evaluate, 10);\n    }; // might not be there yet or might have already rendered everything\n\n\n    if (belowMarkerRef.current) {\n      scrollParents = findScrollParents(belowMarkerRef.current);\n      scrollParents.forEach(function (sp) {\n        return sp.addEventListener('scroll', debounce);\n      });\n    }\n\n    window.addEventListener('resize', debounce);\n    evaluate();\n    return function () {\n      if (scrollParents) {\n        scrollParents.forEach(function (sp) {\n          return sp.removeEventListener('scroll', debounce);\n        });\n      }\n\n      window.removeEventListener('resize', debounce);\n      clearTimeout(timer);\n    };\n  }, [pageHeights, renderPageBounds, replace, show, step]); // check if we need to ask for more\n\n  useEffect(function () {\n    if (onMore && renderPageBounds[1] === lastPage && items.length >= pendingLength && items.length > 0) {\n      // remember we've asked for more, so we don't keep asking if it takes\n      // a while\n      setPendingLength(items.length + 1);\n      onMore();\n    }\n  }, [items.length, lastPage, onMore, pendingLength, renderPageBounds, step]);\n  useEffect(function () {\n    if (items.length === 0 && lastPage === 0 && pendingLength !== 0) {\n      setPageHeights([]);\n      setPendingLength(0);\n      setRenderPageBounds([0, calculateLastPageBound(show, step)]);\n    }\n  }, [lastPage, pendingLength, show, step, items.length]); // scroll to any 'show'\n\n  useLayoutEffect(function () {\n    // ride out any animation delays, 100ms empirically measured\n    var timer = setTimeout(function () {\n      if (show && belowMarkerRef.current && show !== scrollShow) {\n        // calculate show index based on beginPage\n        var showIndex = show - renderPageBounds[0] * step + (renderPageBounds[0] ? 1 : 0);\n        var showNode = belowMarkerRef.current.parentNode.children.item(showIndex);\n\n        if (showNode) {\n          var scrollParent = findScrollParent(showNode);\n\n          if (isNodeBeforeScroll(showNode, scrollParent)) {\n            showNode.scrollIntoView(true);\n          } else if (isNodeAfterScroll(showNode, scrollParent)) {\n            showNode.scrollIntoView(false);\n          } // clean up after having shown\n\n\n          setScrollShow(show);\n        }\n      }\n    }, 100);\n    return function () {\n      return clearTimeout(timer);\n    }; // Omitting scrollShow as a dependency due to concern that setScrollShow\n    // is being called within the timer. If left included, re-renders and other\n    // dependency values could change in an unpredictable manner during timer\n    // and potentially result in an infinite loop.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [renderPageBounds, show, step]); // calculate and keep track of page heights\n\n  useLayoutEffect(function () {\n    // if don't have a belowMarker, we must have rendered everything already\n    if (!belowMarkerRef.current) return; // calculate page heights for rendered pages\n\n    var rendered = belowMarkerRef.current.parentNode.children; // ensure we've rendered the state we have\n    // above? + items in rendered pages + below === rendered DOM elements length\n\n    if ((aboveMarkerRef.current ? 1 : 0) + (renderPageBounds[1] - renderPageBounds[0] + 1) * step + 1 === rendered.length) {\n      var nextPageHeights; // step through each page\n\n      var i = renderPageBounds[0];\n      var lastBottom;\n\n      while (i <= renderPageBounds[1]) {\n        var topIndex = (aboveMarkerRef.current ? 1 : 0) + (i - renderPageBounds[0]) * step;\n        var bottomIndex = Math.min(topIndex + step - 1, rendered.length - 1); // we use lastBottom for top to ensure grid layouts work\n\n        var top = lastBottom !== undefined ? lastBottom : rendered.item(topIndex).getBoundingClientRect().top;\n\n        var _rendered$item$getBou = rendered.item(bottomIndex).getBoundingClientRect(),\n            bottom = _rendered$item$getBou.bottom;\n\n        var height = bottom - top;\n\n        if (bottom && (!pageHeights || pageHeights[i] !== height)) {\n          if (!nextPageHeights) nextPageHeights = [].concat(pageHeights || []);\n          nextPageHeights[i] = height;\n        }\n\n        lastBottom = bottom;\n        i += 1;\n      } // estimate page heights for pages we haven't rendered yet\n\n\n      while (replace && i <= lastPage) {\n        if (!pageHeights[i] && pageHeights[i] !== pageHeights[0]) {\n          if (!nextPageHeights) nextPageHeights = [].concat(pageHeights || []);\n          var _nextPageHeights = nextPageHeights;\n          nextPageHeights[i] = _nextPageHeights[0];\n        }\n\n        i += 1;\n      }\n\n      if (nextPageHeights) setPageHeights(nextPageHeights);\n    }\n  }, [lastPage, pageHeights, renderPageBounds, replace, step]); // calculate the height above the first rendered page using the pageHeights\n\n  var aboveHeight = useMemo(function () {\n    if (!replace) return 0;\n    var height = 0;\n    var i = 0;\n\n    while (i < renderPageBounds[0]) {\n      height += pageHeights[i] || 0;\n      i += 1;\n    }\n\n    return height;\n  }, [pageHeights, renderPageBounds, replace]); // calculate the height below the last rendered page using the pageHeights\n\n  var belowHeight = useMemo(function () {\n    if (!replace) return 0;\n    var height = 0;\n    var i = renderPageBounds[1] + 1;\n\n    while (i <= lastPage) {\n      height += pageHeights[i] || 0;\n      i += 1;\n    }\n\n    return height;\n  }, [lastPage, pageHeights, renderPageBounds, replace]);\n  var firstIndex = renderPageBounds[0] * step;\n  var lastIndex = Math.min((renderPageBounds[1] + 1) * step, items.length) - 1;\n  var result = [];\n\n  if (aboveHeight) {\n    var marker = /*#__PURE__*/React.createElement(Box, {\n      key: \"above\",\n      ref: aboveMarkerRef,\n      flex: false,\n      height: aboveHeight + \"px\"\n    });\n\n    if (renderMarker) {\n      // need to give it a key\n      marker = /*#__PURE__*/React.cloneElement(renderMarker(marker), {\n        key: 'above'\n      });\n    }\n\n    result.push(marker);\n  }\n\n  items.slice(firstIndex, lastIndex + 1).forEach(function (item, index) {\n    var itemsIndex = firstIndex + index;\n    var child = children(item, itemsIndex);\n    result.push(child);\n  });\n\n  if (replace || renderPageBounds[1] < lastPage || onMore) {\n    var _marker = /*#__PURE__*/React.createElement(Box, {\n      key: \"below\",\n      ref: !renderMarker && belowMarkerRef || undefined,\n      flex: false,\n      height: (belowHeight || 0) + \"px\"\n    });\n\n    if (renderMarker) {\n      // need to give it a key\n      var renderedMarker = renderMarker(_marker);\n      _marker = /*#__PURE__*/React.cloneElement(renderedMarker, {\n        key: 'below',\n        // We need to make sure our belowMarkerRef is tied to a component\n        // that has the same parent as the items being rendered. This is so\n        // we can use belowMarkerRef.current.parentNode.children to\n        // get a reference to the items in the DOM for calculating pageHeights.\n        //\n        // Since the caller might have included a ref in what their\n        // renderMarker returns, we have to take care of both refs.\n        // https://github.com/facebook/react/issues/8873#issuecomment-489579878\n        ref: function ref(node) {\n          // Keep your own reference\n          belowMarkerRef.current = node; // Call the original ref, if any\n\n          var ref = renderedMarker.ref;\n\n          if (typeof ref === 'function') {\n            ref(node);\n          } else if (ref !== null) {\n            ref.current = node;\n          }\n        }\n      });\n    }\n\n    result.push(_marker);\n  }\n\n  return result;\n};\n\nInfiniteScroll.propTypes = InfiniteScrollPropTypes;\nexport { InfiniteScroll };"],"mappings":"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"},"metadata":{},"sourceType":"module"}