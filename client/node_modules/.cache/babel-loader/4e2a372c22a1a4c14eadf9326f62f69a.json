{"ast":null,"code":"var _excluded = [\"children\", \"errors\", \"infos\", \"messages\", \"onChange\", \"onReset\", \"onSubmit\", \"onValidate\", \"validate\", \"value\"];\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nimport React, { forwardRef, useCallback, useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport { MessageContext } from '../../contexts/MessageContext';\nimport { FormContext } from './FormContext';\nimport { FormPropTypes } from './propTypes';\nvar defaultValue = {};\nvar defaultTouched = {};\nvar defaultValidationResults = {\n  errors: {},\n  infos: {}\n};\n\nvar stringToArray = function stringToArray(string) {\n  var match = string == null ? void 0 : string.match(/^(.+)\\[([0-9]+)\\]\\.(.*)$/);\n\n  if (match) {\n    var arrayName = match[1],\n        indexOfArray = match[2],\n        arrayObjName = match[3];\n    return {\n      indexOfArray: indexOfArray,\n      arrayName: arrayName,\n      arrayObjName: arrayObjName\n    };\n  }\n\n  return undefined;\n};\n\nvar getFieldValue = function getFieldValue(name, value) {\n  var isArrayField = stringToArray(name);\n\n  if (isArrayField) {\n    var _value$arrayName;\n\n    var indexOfArray = isArrayField.indexOfArray,\n        arrayName = isArrayField.arrayName,\n        arrayObjName = isArrayField.arrayObjName;\n    var obj = (_value$arrayName = value[arrayName]) == null ? void 0 : _value$arrayName[indexOfArray];\n    return arrayObjName ? obj == null ? void 0 : obj[arrayObjName] : obj;\n  }\n\n  return value[name];\n};\n\nvar setFieldValue = function setFieldValue(name, componentValue, prevValue) {\n  var nextValue = _extends({}, prevValue);\n\n  var isArrayField = stringToArray(name);\n\n  if (isArrayField) {\n    var indexOfArray = isArrayField.indexOfArray,\n        arrayName = isArrayField.arrayName,\n        arrayObjName = isArrayField.arrayObjName;\n    if (!nextValue[arrayName]) nextValue[arrayName] = [];\n\n    if (arrayObjName) {\n      var _nextValue$arrayName$;\n\n      if (!nextValue[arrayName][indexOfArray]) nextValue[arrayName][indexOfArray] = (_nextValue$arrayName$ = {}, _nextValue$arrayName$[arrayObjName] = componentValue, _nextValue$arrayName$);\n      nextValue[arrayName][indexOfArray][arrayObjName] = componentValue;\n    } else nextValue[arrayName][indexOfArray] = componentValue;\n  } else {\n    nextValue[name] = componentValue;\n  }\n\n  return nextValue;\n}; // Apply validation rule to field value and send correct messaging.\n\n\nvar validate = function validate(rule, fieldValue, formValue, format, messages) {\n  var result;\n\n  if (typeof rule === 'function') {\n    result = rule(fieldValue, formValue);\n  } else if (rule.regexp) {\n    if (!rule.regexp.test(fieldValue)) {\n      result = rule.message || format({\n        id: 'form.invalid',\n        messages: messages\n      });\n\n      if (rule.status) {\n        result = {\n          message: result,\n          status: rule.status\n        };\n      }\n    }\n  }\n\n  return result;\n}; // Validates particular key in formValue\n\n\nvar validateName = function validateName(validationRules, required) {\n  return function (name, formValue, format, messages) {\n    var fieldValue = getFieldValue(name, formValue);\n    var validationResult;\n\n    if (required && ( // false is for CheckBox\n    fieldValue === undefined || fieldValue === '' || fieldValue === false || Array.isArray(fieldValue) && !fieldValue.length)) {\n      validationResult = format({\n        id: 'form.required',\n        messages: messages\n      });\n    } else if (validationRules) {\n      if (Array.isArray(validationRules)) {\n        validationRules.some(function (rule) {\n          validationResult = validate(rule, fieldValue, formValue, format, messages);\n          return !!validationResult;\n        });\n      } else {\n        validationResult = validate(validationRules, fieldValue, formValue, format, messages);\n      }\n    }\n\n    return validationResult;\n  };\n}; // Validates all keys in formValue\n\n\nvar validateForm = function validateForm(validationRules, formValue, format, messages, omitValid) {\n  var nextErrors = {};\n  var nextInfos = {};\n  validationRules.forEach(function (_ref) {\n    var name = _ref[0],\n        _ref$ = _ref[1],\n        field = _ref$.field,\n        input = _ref$.input;\n\n    if (!omitValid) {\n      nextErrors[name] = undefined;\n      nextInfos[name] = undefined;\n    }\n\n    var result;\n\n    if (input) {\n      // input() a validation function supplied through useFormInput()\n      result = input(name, formValue, format, messages);\n    }\n\n    if (field && !result) {\n      // field() a validation function supplied through useFormField()\n      result = field(name, formValue, format, messages);\n    } // typeof error === 'object' is implied for both cases of error with\n    // a status message and for an error object that is a react node\n\n\n    if (typeof result === 'object') {\n      if (result.status === 'info') {\n        nextInfos[name] = result.message;\n      } else {\n        nextErrors[name] = result.message || result; // could be a node\n      }\n    } else if (typeof result === 'string') {\n      nextErrors[name] = result;\n    }\n  });\n  return [nextErrors, nextInfos];\n};\n\nvar Form = /*#__PURE__*/forwardRef(function (_ref2, ref) {\n  var children = _ref2.children,\n      _ref2$errors = _ref2.errors,\n      errorsProp = _ref2$errors === void 0 ? defaultValidationResults.errors : _ref2$errors,\n      _ref2$infos = _ref2.infos,\n      infosProp = _ref2$infos === void 0 ? defaultValidationResults.infos : _ref2$infos,\n      messages = _ref2.messages,\n      onChange = _ref2.onChange,\n      _onReset = _ref2.onReset,\n      _onSubmit = _ref2.onSubmit,\n      onValidate = _ref2.onValidate,\n      _ref2$validate = _ref2.validate,\n      validateOn = _ref2$validate === void 0 ? 'submit' : _ref2$validate,\n      valueProp = _ref2.value,\n      rest = _objectWithoutPropertiesLoose(_ref2, _excluded);\n\n  var _useContext = useContext(MessageContext),\n      format = _useContext.format;\n\n  var _useState = useState(valueProp || defaultValue),\n      valueState = _useState[0],\n      setValueState = _useState[1];\n\n  var value = useMemo(function () {\n    return valueProp || valueState;\n  }, [valueProp, valueState]);\n\n  var _useState2 = useState(defaultTouched),\n      touched = _useState2[0],\n      setTouched = _useState2[1];\n\n  var _useState3 = useState({\n    errors: errorsProp,\n    infos: infosProp\n  }),\n      validationResults = _useState3[0],\n      setValidationResults = _useState3[1]; // maintain a copy of validationResults in a ref for useEffects\n  // which can't depend on validationResults directly without\n  // causing infinite renders.\n\n\n  var validationResultsRef = useRef({}); // Simulated onMount state. Consider Form to be mounted once it has\n  // accounted for values originating from controlled inputs (available\n  // at second rendering).\n\n  var _useState4 = useState('unmounted'),\n      mounted = _useState4[0],\n      setMounted = _useState4[1];\n\n  useEffect(function () {\n    if (!mounted) setMounted('mounting');else if (mounted === 'mounting') setMounted('mounted');\n  }, [mounted]); // `pendingValidation` is the name of the FormField awaiting validation.\n\n  var _useState5 = useState(undefined),\n      pendingValidation = _useState5[0],\n      setPendingValidation = _useState5[1];\n\n  var validationRulesRef = useRef({});\n  var requiredFields = useRef([]);\n  var buildValid = useCallback(function (nextErrors) {\n    var valid = false;\n    valid = requiredFields.current.filter(function (n) {\n      return Object.keys(validationRulesRef.current).includes(n);\n    }).every(function (field) {\n      return value[field] && (value[field] !== '' || value[field] !== false);\n    });\n    if (Object.keys(nextErrors).length > 0) valid = false;\n    return valid;\n  }, [value]); // Only keep validation results for current form fields. In the case of a\n  // dynamic form, a field possessing an error may have been removed from the\n  // form; need to clean up any previous related validation results.\n\n  var filterRemovedFields = function filterRemovedFields(prevValidations) {\n    var nextValidations = prevValidations;\n    return Object.keys(nextValidations).filter(function (n) {\n      return !validationRulesRef.current[n] || nextValidations[n] === undefined;\n    }).forEach(function (n) {\n      return delete nextValidations[n];\n    });\n  };\n\n  var applyValidationRules = useCallback(function (validationRules) {\n    var _validateForm = validateForm(validationRules, value, format, messages),\n        validatedErrors = _validateForm[0],\n        validatedInfos = _validateForm[1];\n\n    setValidationResults(function (prevValidationResults) {\n      // Keep any previous errors and infos for untouched keys,\n      // these may have come from a Submit.\n      var nextErrors = _extends({}, prevValidationResults.errors, validatedErrors);\n\n      var nextInfos = _extends({}, prevValidationResults.infos, validatedInfos); // Remove previous errors and infos for keys no longer in the\n      // form, these may have been fields removed from a dynamic form.\n\n\n      filterRemovedFields(nextErrors);\n      filterRemovedFields(nextInfos);\n      var nextValidationResults = {\n        errors: nextErrors,\n        infos: nextInfos\n      };\n      if (onValidate) onValidate(_extends({}, nextValidationResults, {\n        valid: buildValid(nextErrors)\n      }));\n      validationResultsRef.current = nextValidationResults;\n      return nextValidationResults;\n    });\n  }, [buildValid, format, messages, onValidate, value]); // Validate all fields holding values onMount if set to\n  // validate when blur or change.\n\n  useEffect(function () {\n    var validationRules = Object.entries(validationRulesRef.current); // Use simulated onMount state to account for values provided by\n    // controlled inputs.\n\n    if (mounted !== 'mounted' && ['blur', 'change'].includes(validateOn) && Object.keys(value).length > 0 && Object.keys(touched).length === 0) {\n      applyValidationRules(validationRules.filter(function (_ref3) {\n        var n = _ref3[0];\n        return value[n];\n      }) // Exlude empty arrays which may be initial values in\n      // an input such as DateInput.\n      .filter(function (_ref4) {\n        var n = _ref4[0];\n        return !(Array.isArray(value[n]) && value[n].length === 0);\n      }));\n    }\n  }, [applyValidationRules, mounted, touched, validateOn, value]); // Run validation against fields with pendingValidations from onBlur\n  // and/or onChange.\n\n  useEffect(function () {\n    var validationRules = Object.entries(validationRulesRef.current);\n    var timer = setTimeout(function () {\n      if (pendingValidation && ['blur', 'change'].includes(validateOn)) {\n        applyValidationRules(validationRules.filter(function (_ref5) {\n          var n = _ref5[0];\n          return touched[n] || pendingValidation.includes(n);\n        }));\n        setPendingValidation(undefined);\n      } // Complete any potential click events before running onBlur validation.\n      // Otherwise, click events like reset, etc. may not be registered. For a\n      // detailed scenario/discussion, see: https://github.com/grommet/grommet/issues/4863\n      // Values empirically tested; 120 was selected because it is the largest\n      // Chrome: 100, Safari: 120, Firefox: 80\n\n    }, 120);\n    return function () {\n      return clearTimeout(timer);\n    };\n  }, [applyValidationRules, pendingValidation, touched, validateOn]); // Re-run validation rules for all fields with prior errors.\n  // if validate=blur this helps re-validate if there are errors\n  // as the user fixes them (basically act like validate=change for that)\n\n  useEffect(function () {\n    var _validationResultsRef;\n\n    var validationRules = Object.entries(validationRulesRef.current);\n\n    if ((_validationResultsRef = validationResultsRef.current) != null && _validationResultsRef.errors && Object.keys(validationResultsRef.current.errors).length > 0) {\n      applyValidationRules(validationRules.filter(function (_ref6) {\n        var n = _ref6[0];\n        return touched[n] && validationResultsRef.current.errors[n];\n      }));\n    }\n  }, [applyValidationRules, touched]); // There are three basic patterns of handling form input value state:\n  //\n  // 1 - form controlled\n  //\n  // In this model, the caller sets `value` and `onChange` properties\n  // on the Form component to supply the values used by the input fields.\n  // In useFormContext(), componentValue would be undefined and formValue\n  // is be set to whatever the form state has. Whenever the form state\n  // changes, we update the contextValue so the input component will use\n  // that. When the input component changes, we will call update() to\n  // update the form state.\n  //\n  // 2 - input controlled\n  //\n  // In this model, the caller sets `value` and `onChange` properties\n  // on the input components, like TextInput, to supply the value for it.\n  // In useFormContext(), componentValue is this value and we ensure to\n  // update the form state, via update(), and set the contextValue from\n  // the componentValue. When the input component changes, we will\n  // call update() to update the form state.\n  //\n  // 3 - uncontrolled\n  //\n  // In this model, the caller doesn't set a `value` or `onChange` property\n  // at either the form or input component levels.\n  // In useFormContext(), componentValue is undefined and valueProp is\n  // undefined and nothing much happens here. That is, unless the\n  // calling component needs to know the state in order to work, such\n  // as CheckBox or Select. In this case, those components supply\n  // an initialValue, which will trigger updating the contextValue so\n  // they can have access to it.\n  //\n\n  var formContextValue = useMemo(function () {\n    var useFormInput = function useFormInput(_ref7) {\n      var name = _ref7.name,\n          componentValue = _ref7.value,\n          initialValue = _ref7.initialValue,\n          validateArg = _ref7.validate;\n\n      var _useState6 = useState(initialValue),\n          inputValue = _useState6[0],\n          setInputValue = _useState6[1];\n\n      var formValue = name ? getFieldValue(name, value) : undefined; // for dynamic forms, we need to track when an input has been added to\n      // the form value. if the input is unmounted, we will delete its\n      // key/value from the form value.\n\n      var keyCreated = useRef(false); // This effect is for pattern #2, where the controlled input\n      // component is driving the value via componentValue.\n\n      useEffect(function () {\n        if (name && // we have somewhere to put this\n        componentValue !== undefined && // input driving\n        componentValue !== formValue // don't already have it\n        ) {\n          setValueState(function (prevValue) {\n            return setFieldValue(name, componentValue, prevValue);\n          }); // don't onChange on programmatic changes\n        }\n      }, [componentValue, formValue, name]); // on unmount, if the form is uncontrolled, remove the key/value\n      // from the form value\n\n      useEffect(function () {\n        return function () {\n          if (keyCreated.current) {\n            keyCreated.current = false;\n            setValueState(function (prevValue) {\n              var nextValue = _extends({}, prevValue);\n\n              var isArrayField = stringToArray(name);\n\n              if (isArrayField) {\n                var arrayName = isArrayField.arrayName;\n                delete nextValue[arrayName];\n              } else {\n                delete nextValue[name];\n              }\n\n              return nextValue;\n            });\n          }\n        };\n      }, // eslint-disable-next-line react-hooks/exhaustive-deps\n      [] // only run onmount and unmount\n      ); // Create validation rules for fields\n\n      useEffect(function () {\n        if (validateArg) {\n          if (!validationRulesRef.current[name]) {\n            validationRulesRef.current[name] = {};\n          }\n\n          validationRulesRef.current[name].input = validateName(validateArg);\n          return function () {\n            return delete validationRulesRef.current[name].input;\n          };\n        }\n\n        return undefined;\n      }, [validateArg, name]);\n      var useValue;\n      if (componentValue !== undefined) // input component drives, pattern #2\n        useValue = componentValue;else if (valueProp && name && formValue !== undefined) // form drives, pattern #1\n        useValue = formValue;else if (formValue === undefined && name) // form has reset, so reset input value as well\n        useValue = initialValue;else useValue = inputValue;\n      return [useValue, function (nextComponentValue) {\n        if (name) {\n          // we have somewhere to put this\n          var nextTouched = _extends({}, touched);\n\n          nextTouched[name] = true;\n\n          if (!touched[name]) {\n            // don't update if not needed\n            setTouched(nextTouched);\n          } // if nextValue doesn't have a key for name, this must be\n          // uncontrolled form. we will flag this field was added so\n          // we know to remove its value from the form if it is dynamically\n          // removed\n\n\n          if (!(name in value)) keyCreated.current = true;\n          var nextValue = setFieldValue(name, nextComponentValue, value);\n          setValueState(nextValue);\n          if (onChange) onChange(nextValue, {\n            touched: nextTouched\n          });\n        }\n\n        if (initialValue !== undefined) setInputValue(nextComponentValue);\n      }];\n    };\n\n    var useFormField = function useFormField(_ref8) {\n      var errorArg = _ref8.error,\n          infoArg = _ref8.info,\n          name = _ref8.name,\n          required = _ref8.required,\n          disabled = _ref8.disabled,\n          validateArg = _ref8.validate;\n      var error = disabled ? undefined : errorArg || validationResults.errors[name];\n      var info = infoArg || validationResults.infos[name]; // Create validation rules for field\n\n      useEffect(function () {\n        var index = requiredFields.current.indexOf(name);\n\n        if (required) {\n          if (index === -1) requiredFields.current.push(name);\n        } else if (index !== -1) requiredFields.current.splice(index, 1);\n\n        if (validateArg || required) {\n          if (!validationRulesRef.current[name]) {\n            validationRulesRef.current[name] = {};\n          }\n\n          validationRulesRef.current[name].field = validateName(validateArg, required);\n          return function () {\n            delete validationRulesRef.current[name].field;\n            var requiredFieldIndex = requiredFields.current.indexOf(name);\n\n            if (requiredFieldIndex !== -1) {\n              requiredFields.current.splice(requiredFieldIndex, 1);\n            }\n          };\n        }\n\n        return undefined;\n      }, [error, name, required, validateArg, disabled]);\n      return {\n        error: error,\n        info: info,\n        inForm: true,\n        onBlur: validateOn === 'blur' ? function () {\n          return setPendingValidation(pendingValidation ? [].concat(pendingValidation, [name]) : [name]);\n        } : undefined,\n        onChange: validateOn === 'change' ? function () {\n          return setPendingValidation(pendingValidation ? [].concat(pendingValidation, [name]) : [name]);\n        } : undefined\n      };\n    };\n\n    return {\n      useFormField: useFormField,\n      useFormInput: useFormInput\n    };\n  }, [onChange, pendingValidation, touched, validateOn, validationResults.errors, validationResults.infos, value, valueProp]);\n  return /*#__PURE__*/React.createElement(\"form\", _extends({\n    ref: ref\n  }, rest, {\n    onReset: function onReset(event) {\n      setPendingValidation(undefined);\n\n      if (!valueProp) {\n        setValueState(defaultValue);\n        if (onChange) onChange(defaultValue, {\n          touched: defaultTouched\n        });\n      }\n\n      setTouched(defaultTouched);\n      setValidationResults(defaultValidationResults);\n\n      if (_onReset) {\n        event.persist(); // extract from React's synthetic event pool\n\n        var adjustedEvent = event;\n        adjustedEvent.value = defaultValue;\n\n        _onReset(adjustedEvent);\n      }\n    },\n    onSubmit: function onSubmit(event) {\n      // Don't submit the form via browser form action. We don't want it\n      // if the validation fails. And, we assume a javascript action handler\n      // otherwise.\n      event.preventDefault();\n      setPendingValidation(undefined);\n\n      var _validateForm2 = validateForm(Object.entries(validationRulesRef.current), value, format, messages, true),\n          nextErrors = _validateForm2[0],\n          nextInfos = _validateForm2[1];\n\n      setValidationResults(function () {\n        var nextValidationResults = {\n          errors: nextErrors,\n          infos: nextInfos,\n          // Show form's validity when clicking on Submit\n          valid: buildValid(nextErrors)\n        };\n        if (onValidate) onValidate(nextValidationResults);\n        validationResultsRef.current = nextValidationResults;\n        return nextValidationResults;\n      });\n\n      if (Object.keys(nextErrors).length === 0 && _onSubmit) {\n        event.persist(); // extract from React's synthetic event pool\n\n        var adjustedEvent = event;\n        adjustedEvent.value = value;\n        adjustedEvent.touched = touched;\n\n        _onSubmit(adjustedEvent);\n      }\n    }\n  }), /*#__PURE__*/React.createElement(FormContext.Provider, {\n    value: formContextValue\n  }, children));\n});\nForm.displayName = 'Form';\nForm.propTypes = FormPropTypes;\nexport { Form };","map":{"version":3,"names":["_excluded","_objectWithoutPropertiesLoose","source","excluded","target","sourceKeys","Object","keys","key","i","length","indexOf","_extends","assign","bind","arguments","prototype","hasOwnProperty","call","apply","React","forwardRef","useCallback","useContext","useEffect","useMemo","useRef","useState","MessageContext","FormContext","FormPropTypes","defaultValue","defaultTouched","defaultValidationResults","errors","infos","stringToArray","string","match","arrayName","indexOfArray","arrayObjName","undefined","getFieldValue","name","value","isArrayField","_value$arrayName","obj","setFieldValue","componentValue","prevValue","nextValue","_nextValue$arrayName$","validate","rule","fieldValue","formValue","format","messages","result","regexp","test","message","id","status","validateName","validationRules","required","validationResult","Array","isArray","some","validateForm","omitValid","nextErrors","nextInfos","forEach","_ref","_ref$","field","input","Form","_ref2","ref","children","_ref2$errors","errorsProp","_ref2$infos","infosProp","onChange","_onReset","onReset","_onSubmit","onSubmit","onValidate","_ref2$validate","validateOn","valueProp","rest","_useContext","_useState","valueState","setValueState","_useState2","touched","setTouched","_useState3","validationResults","setValidationResults","validationResultsRef","_useState4","mounted","setMounted","_useState5","pendingValidation","setPendingValidation","validationRulesRef","requiredFields","buildValid","valid","current","filter","n","includes","every","filterRemovedFields","prevValidations","nextValidations","applyValidationRules","_validateForm","validatedErrors","validatedInfos","prevValidationResults","nextValidationResults","entries","_ref3","_ref4","timer","setTimeout","_ref5","clearTimeout","_validationResultsRef","_ref6","formContextValue","useFormInput","_ref7","initialValue","validateArg","_useState6","inputValue","setInputValue","keyCreated","useValue","nextComponentValue","nextTouched","useFormField","_ref8","errorArg","error","infoArg","info","disabled","index","push","splice","requiredFieldIndex","inForm","onBlur","concat","createElement","event","persist","adjustedEvent","preventDefault","_validateForm2","Provider","displayName","propTypes"],"sources":["/Users/siddharthkhatri/Developer/React JS/phone-book/client/node_modules/grommet/es6/components/Form/Form.js"],"sourcesContent":["var _excluded = [\"children\", \"errors\", \"infos\", \"messages\", \"onChange\", \"onReset\", \"onSubmit\", \"onValidate\", \"validate\", \"value\"];\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React, { forwardRef, useCallback, useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport { MessageContext } from '../../contexts/MessageContext';\nimport { FormContext } from './FormContext';\nimport { FormPropTypes } from './propTypes';\nvar defaultValue = {};\nvar defaultTouched = {};\nvar defaultValidationResults = {\n  errors: {},\n  infos: {}\n};\n\nvar stringToArray = function stringToArray(string) {\n  var match = string == null ? void 0 : string.match(/^(.+)\\[([0-9]+)\\]\\.(.*)$/);\n\n  if (match) {\n    var arrayName = match[1],\n        indexOfArray = match[2],\n        arrayObjName = match[3];\n    return {\n      indexOfArray: indexOfArray,\n      arrayName: arrayName,\n      arrayObjName: arrayObjName\n    };\n  }\n\n  return undefined;\n};\n\nvar getFieldValue = function getFieldValue(name, value) {\n  var isArrayField = stringToArray(name);\n\n  if (isArrayField) {\n    var _value$arrayName;\n\n    var indexOfArray = isArrayField.indexOfArray,\n        arrayName = isArrayField.arrayName,\n        arrayObjName = isArrayField.arrayObjName;\n    var obj = (_value$arrayName = value[arrayName]) == null ? void 0 : _value$arrayName[indexOfArray];\n    return arrayObjName ? obj == null ? void 0 : obj[arrayObjName] : obj;\n  }\n\n  return value[name];\n};\n\nvar setFieldValue = function setFieldValue(name, componentValue, prevValue) {\n  var nextValue = _extends({}, prevValue);\n\n  var isArrayField = stringToArray(name);\n\n  if (isArrayField) {\n    var indexOfArray = isArrayField.indexOfArray,\n        arrayName = isArrayField.arrayName,\n        arrayObjName = isArrayField.arrayObjName;\n    if (!nextValue[arrayName]) nextValue[arrayName] = [];\n\n    if (arrayObjName) {\n      var _nextValue$arrayName$;\n\n      if (!nextValue[arrayName][indexOfArray]) nextValue[arrayName][indexOfArray] = (_nextValue$arrayName$ = {}, _nextValue$arrayName$[arrayObjName] = componentValue, _nextValue$arrayName$);\n      nextValue[arrayName][indexOfArray][arrayObjName] = componentValue;\n    } else nextValue[arrayName][indexOfArray] = componentValue;\n  } else {\n    nextValue[name] = componentValue;\n  }\n\n  return nextValue;\n}; // Apply validation rule to field value and send correct messaging.\n\n\nvar validate = function validate(rule, fieldValue, formValue, format, messages) {\n  var result;\n\n  if (typeof rule === 'function') {\n    result = rule(fieldValue, formValue);\n  } else if (rule.regexp) {\n    if (!rule.regexp.test(fieldValue)) {\n      result = rule.message || format({\n        id: 'form.invalid',\n        messages: messages\n      });\n\n      if (rule.status) {\n        result = {\n          message: result,\n          status: rule.status\n        };\n      }\n    }\n  }\n\n  return result;\n}; // Validates particular key in formValue\n\n\nvar validateName = function validateName(validationRules, required) {\n  return function (name, formValue, format, messages) {\n    var fieldValue = getFieldValue(name, formValue);\n    var validationResult;\n\n    if (required && ( // false is for CheckBox\n    fieldValue === undefined || fieldValue === '' || fieldValue === false || Array.isArray(fieldValue) && !fieldValue.length)) {\n      validationResult = format({\n        id: 'form.required',\n        messages: messages\n      });\n    } else if (validationRules) {\n      if (Array.isArray(validationRules)) {\n        validationRules.some(function (rule) {\n          validationResult = validate(rule, fieldValue, formValue, format, messages);\n          return !!validationResult;\n        });\n      } else {\n        validationResult = validate(validationRules, fieldValue, formValue, format, messages);\n      }\n    }\n\n    return validationResult;\n  };\n}; // Validates all keys in formValue\n\n\nvar validateForm = function validateForm(validationRules, formValue, format, messages, omitValid) {\n  var nextErrors = {};\n  var nextInfos = {};\n  validationRules.forEach(function (_ref) {\n    var name = _ref[0],\n        _ref$ = _ref[1],\n        field = _ref$.field,\n        input = _ref$.input;\n\n    if (!omitValid) {\n      nextErrors[name] = undefined;\n      nextInfos[name] = undefined;\n    }\n\n    var result;\n\n    if (input) {\n      // input() a validation function supplied through useFormInput()\n      result = input(name, formValue, format, messages);\n    }\n\n    if (field && !result) {\n      // field() a validation function supplied through useFormField()\n      result = field(name, formValue, format, messages);\n    } // typeof error === 'object' is implied for both cases of error with\n    // a status message and for an error object that is a react node\n\n\n    if (typeof result === 'object') {\n      if (result.status === 'info') {\n        nextInfos[name] = result.message;\n      } else {\n        nextErrors[name] = result.message || result; // could be a node\n      }\n    } else if (typeof result === 'string') {\n      nextErrors[name] = result;\n    }\n  });\n  return [nextErrors, nextInfos];\n};\n\nvar Form = /*#__PURE__*/forwardRef(function (_ref2, ref) {\n  var children = _ref2.children,\n      _ref2$errors = _ref2.errors,\n      errorsProp = _ref2$errors === void 0 ? defaultValidationResults.errors : _ref2$errors,\n      _ref2$infos = _ref2.infos,\n      infosProp = _ref2$infos === void 0 ? defaultValidationResults.infos : _ref2$infos,\n      messages = _ref2.messages,\n      onChange = _ref2.onChange,\n      _onReset = _ref2.onReset,\n      _onSubmit = _ref2.onSubmit,\n      onValidate = _ref2.onValidate,\n      _ref2$validate = _ref2.validate,\n      validateOn = _ref2$validate === void 0 ? 'submit' : _ref2$validate,\n      valueProp = _ref2.value,\n      rest = _objectWithoutPropertiesLoose(_ref2, _excluded);\n\n  var _useContext = useContext(MessageContext),\n      format = _useContext.format;\n\n  var _useState = useState(valueProp || defaultValue),\n      valueState = _useState[0],\n      setValueState = _useState[1];\n\n  var value = useMemo(function () {\n    return valueProp || valueState;\n  }, [valueProp, valueState]);\n\n  var _useState2 = useState(defaultTouched),\n      touched = _useState2[0],\n      setTouched = _useState2[1];\n\n  var _useState3 = useState({\n    errors: errorsProp,\n    infos: infosProp\n  }),\n      validationResults = _useState3[0],\n      setValidationResults = _useState3[1]; // maintain a copy of validationResults in a ref for useEffects\n  // which can't depend on validationResults directly without\n  // causing infinite renders.\n\n\n  var validationResultsRef = useRef({}); // Simulated onMount state. Consider Form to be mounted once it has\n  // accounted for values originating from controlled inputs (available\n  // at second rendering).\n\n  var _useState4 = useState('unmounted'),\n      mounted = _useState4[0],\n      setMounted = _useState4[1];\n\n  useEffect(function () {\n    if (!mounted) setMounted('mounting');else if (mounted === 'mounting') setMounted('mounted');\n  }, [mounted]); // `pendingValidation` is the name of the FormField awaiting validation.\n\n  var _useState5 = useState(undefined),\n      pendingValidation = _useState5[0],\n      setPendingValidation = _useState5[1];\n\n  var validationRulesRef = useRef({});\n  var requiredFields = useRef([]);\n  var buildValid = useCallback(function (nextErrors) {\n    var valid = false;\n    valid = requiredFields.current.filter(function (n) {\n      return Object.keys(validationRulesRef.current).includes(n);\n    }).every(function (field) {\n      return value[field] && (value[field] !== '' || value[field] !== false);\n    });\n    if (Object.keys(nextErrors).length > 0) valid = false;\n    return valid;\n  }, [value]); // Only keep validation results for current form fields. In the case of a\n  // dynamic form, a field possessing an error may have been removed from the\n  // form; need to clean up any previous related validation results.\n\n  var filterRemovedFields = function filterRemovedFields(prevValidations) {\n    var nextValidations = prevValidations;\n    return Object.keys(nextValidations).filter(function (n) {\n      return !validationRulesRef.current[n] || nextValidations[n] === undefined;\n    }).forEach(function (n) {\n      return delete nextValidations[n];\n    });\n  };\n\n  var applyValidationRules = useCallback(function (validationRules) {\n    var _validateForm = validateForm(validationRules, value, format, messages),\n        validatedErrors = _validateForm[0],\n        validatedInfos = _validateForm[1];\n\n    setValidationResults(function (prevValidationResults) {\n      // Keep any previous errors and infos for untouched keys,\n      // these may have come from a Submit.\n      var nextErrors = _extends({}, prevValidationResults.errors, validatedErrors);\n\n      var nextInfos = _extends({}, prevValidationResults.infos, validatedInfos); // Remove previous errors and infos for keys no longer in the\n      // form, these may have been fields removed from a dynamic form.\n\n\n      filterRemovedFields(nextErrors);\n      filterRemovedFields(nextInfos);\n      var nextValidationResults = {\n        errors: nextErrors,\n        infos: nextInfos\n      };\n      if (onValidate) onValidate(_extends({}, nextValidationResults, {\n        valid: buildValid(nextErrors)\n      }));\n      validationResultsRef.current = nextValidationResults;\n      return nextValidationResults;\n    });\n  }, [buildValid, format, messages, onValidate, value]); // Validate all fields holding values onMount if set to\n  // validate when blur or change.\n\n  useEffect(function () {\n    var validationRules = Object.entries(validationRulesRef.current); // Use simulated onMount state to account for values provided by\n    // controlled inputs.\n\n    if (mounted !== 'mounted' && ['blur', 'change'].includes(validateOn) && Object.keys(value).length > 0 && Object.keys(touched).length === 0) {\n      applyValidationRules(validationRules.filter(function (_ref3) {\n        var n = _ref3[0];\n        return value[n];\n      }) // Exlude empty arrays which may be initial values in\n      // an input such as DateInput.\n      .filter(function (_ref4) {\n        var n = _ref4[0];\n        return !(Array.isArray(value[n]) && value[n].length === 0);\n      }));\n    }\n  }, [applyValidationRules, mounted, touched, validateOn, value]); // Run validation against fields with pendingValidations from onBlur\n  // and/or onChange.\n\n  useEffect(function () {\n    var validationRules = Object.entries(validationRulesRef.current);\n    var timer = setTimeout(function () {\n      if (pendingValidation && ['blur', 'change'].includes(validateOn)) {\n        applyValidationRules(validationRules.filter(function (_ref5) {\n          var n = _ref5[0];\n          return touched[n] || pendingValidation.includes(n);\n        }));\n        setPendingValidation(undefined);\n      } // Complete any potential click events before running onBlur validation.\n      // Otherwise, click events like reset, etc. may not be registered. For a\n      // detailed scenario/discussion, see: https://github.com/grommet/grommet/issues/4863\n      // Values empirically tested; 120 was selected because it is the largest\n      // Chrome: 100, Safari: 120, Firefox: 80\n\n    }, 120);\n    return function () {\n      return clearTimeout(timer);\n    };\n  }, [applyValidationRules, pendingValidation, touched, validateOn]); // Re-run validation rules for all fields with prior errors.\n  // if validate=blur this helps re-validate if there are errors\n  // as the user fixes them (basically act like validate=change for that)\n\n  useEffect(function () {\n    var _validationResultsRef;\n\n    var validationRules = Object.entries(validationRulesRef.current);\n\n    if ((_validationResultsRef = validationResultsRef.current) != null && _validationResultsRef.errors && Object.keys(validationResultsRef.current.errors).length > 0) {\n      applyValidationRules(validationRules.filter(function (_ref6) {\n        var n = _ref6[0];\n        return touched[n] && validationResultsRef.current.errors[n];\n      }));\n    }\n  }, [applyValidationRules, touched]); // There are three basic patterns of handling form input value state:\n  //\n  // 1 - form controlled\n  //\n  // In this model, the caller sets `value` and `onChange` properties\n  // on the Form component to supply the values used by the input fields.\n  // In useFormContext(), componentValue would be undefined and formValue\n  // is be set to whatever the form state has. Whenever the form state\n  // changes, we update the contextValue so the input component will use\n  // that. When the input component changes, we will call update() to\n  // update the form state.\n  //\n  // 2 - input controlled\n  //\n  // In this model, the caller sets `value` and `onChange` properties\n  // on the input components, like TextInput, to supply the value for it.\n  // In useFormContext(), componentValue is this value and we ensure to\n  // update the form state, via update(), and set the contextValue from\n  // the componentValue. When the input component changes, we will\n  // call update() to update the form state.\n  //\n  // 3 - uncontrolled\n  //\n  // In this model, the caller doesn't set a `value` or `onChange` property\n  // at either the form or input component levels.\n  // In useFormContext(), componentValue is undefined and valueProp is\n  // undefined and nothing much happens here. That is, unless the\n  // calling component needs to know the state in order to work, such\n  // as CheckBox or Select. In this case, those components supply\n  // an initialValue, which will trigger updating the contextValue so\n  // they can have access to it.\n  //\n\n  var formContextValue = useMemo(function () {\n    var useFormInput = function useFormInput(_ref7) {\n      var name = _ref7.name,\n          componentValue = _ref7.value,\n          initialValue = _ref7.initialValue,\n          validateArg = _ref7.validate;\n\n      var _useState6 = useState(initialValue),\n          inputValue = _useState6[0],\n          setInputValue = _useState6[1];\n\n      var formValue = name ? getFieldValue(name, value) : undefined; // for dynamic forms, we need to track when an input has been added to\n      // the form value. if the input is unmounted, we will delete its\n      // key/value from the form value.\n\n      var keyCreated = useRef(false); // This effect is for pattern #2, where the controlled input\n      // component is driving the value via componentValue.\n\n      useEffect(function () {\n        if (name && // we have somewhere to put this\n        componentValue !== undefined && // input driving\n        componentValue !== formValue // don't already have it\n        ) {\n          setValueState(function (prevValue) {\n            return setFieldValue(name, componentValue, prevValue);\n          }); // don't onChange on programmatic changes\n        }\n      }, [componentValue, formValue, name]); // on unmount, if the form is uncontrolled, remove the key/value\n      // from the form value\n\n      useEffect(function () {\n        return function () {\n          if (keyCreated.current) {\n            keyCreated.current = false;\n            setValueState(function (prevValue) {\n              var nextValue = _extends({}, prevValue);\n\n              var isArrayField = stringToArray(name);\n\n              if (isArrayField) {\n                var arrayName = isArrayField.arrayName;\n                delete nextValue[arrayName];\n              } else {\n                delete nextValue[name];\n              }\n\n              return nextValue;\n            });\n          }\n        };\n      }, // eslint-disable-next-line react-hooks/exhaustive-deps\n      [] // only run onmount and unmount\n      ); // Create validation rules for fields\n\n      useEffect(function () {\n        if (validateArg) {\n          if (!validationRulesRef.current[name]) {\n            validationRulesRef.current[name] = {};\n          }\n\n          validationRulesRef.current[name].input = validateName(validateArg);\n          return function () {\n            return delete validationRulesRef.current[name].input;\n          };\n        }\n\n        return undefined;\n      }, [validateArg, name]);\n      var useValue;\n      if (componentValue !== undefined) // input component drives, pattern #2\n        useValue = componentValue;else if (valueProp && name && formValue !== undefined) // form drives, pattern #1\n        useValue = formValue;else if (formValue === undefined && name) // form has reset, so reset input value as well\n        useValue = initialValue;else useValue = inputValue;\n      return [useValue, function (nextComponentValue) {\n        if (name) {\n          // we have somewhere to put this\n          var nextTouched = _extends({}, touched);\n\n          nextTouched[name] = true;\n\n          if (!touched[name]) {\n            // don't update if not needed\n            setTouched(nextTouched);\n          } // if nextValue doesn't have a key for name, this must be\n          // uncontrolled form. we will flag this field was added so\n          // we know to remove its value from the form if it is dynamically\n          // removed\n\n\n          if (!(name in value)) keyCreated.current = true;\n          var nextValue = setFieldValue(name, nextComponentValue, value);\n          setValueState(nextValue);\n          if (onChange) onChange(nextValue, {\n            touched: nextTouched\n          });\n        }\n\n        if (initialValue !== undefined) setInputValue(nextComponentValue);\n      }];\n    };\n\n    var useFormField = function useFormField(_ref8) {\n      var errorArg = _ref8.error,\n          infoArg = _ref8.info,\n          name = _ref8.name,\n          required = _ref8.required,\n          disabled = _ref8.disabled,\n          validateArg = _ref8.validate;\n      var error = disabled ? undefined : errorArg || validationResults.errors[name];\n      var info = infoArg || validationResults.infos[name]; // Create validation rules for field\n\n      useEffect(function () {\n        var index = requiredFields.current.indexOf(name);\n\n        if (required) {\n          if (index === -1) requiredFields.current.push(name);\n        } else if (index !== -1) requiredFields.current.splice(index, 1);\n\n        if (validateArg || required) {\n          if (!validationRulesRef.current[name]) {\n            validationRulesRef.current[name] = {};\n          }\n\n          validationRulesRef.current[name].field = validateName(validateArg, required);\n          return function () {\n            delete validationRulesRef.current[name].field;\n            var requiredFieldIndex = requiredFields.current.indexOf(name);\n\n            if (requiredFieldIndex !== -1) {\n              requiredFields.current.splice(requiredFieldIndex, 1);\n            }\n          };\n        }\n\n        return undefined;\n      }, [error, name, required, validateArg, disabled]);\n      return {\n        error: error,\n        info: info,\n        inForm: true,\n        onBlur: validateOn === 'blur' ? function () {\n          return setPendingValidation(pendingValidation ? [].concat(pendingValidation, [name]) : [name]);\n        } : undefined,\n        onChange: validateOn === 'change' ? function () {\n          return setPendingValidation(pendingValidation ? [].concat(pendingValidation, [name]) : [name]);\n        } : undefined\n      };\n    };\n\n    return {\n      useFormField: useFormField,\n      useFormInput: useFormInput\n    };\n  }, [onChange, pendingValidation, touched, validateOn, validationResults.errors, validationResults.infos, value, valueProp]);\n  return /*#__PURE__*/React.createElement(\"form\", _extends({\n    ref: ref\n  }, rest, {\n    onReset: function onReset(event) {\n      setPendingValidation(undefined);\n\n      if (!valueProp) {\n        setValueState(defaultValue);\n        if (onChange) onChange(defaultValue, {\n          touched: defaultTouched\n        });\n      }\n\n      setTouched(defaultTouched);\n      setValidationResults(defaultValidationResults);\n\n      if (_onReset) {\n        event.persist(); // extract from React's synthetic event pool\n\n        var adjustedEvent = event;\n        adjustedEvent.value = defaultValue;\n\n        _onReset(adjustedEvent);\n      }\n    },\n    onSubmit: function onSubmit(event) {\n      // Don't submit the form via browser form action. We don't want it\n      // if the validation fails. And, we assume a javascript action handler\n      // otherwise.\n      event.preventDefault();\n      setPendingValidation(undefined);\n\n      var _validateForm2 = validateForm(Object.entries(validationRulesRef.current), value, format, messages, true),\n          nextErrors = _validateForm2[0],\n          nextInfos = _validateForm2[1];\n\n      setValidationResults(function () {\n        var nextValidationResults = {\n          errors: nextErrors,\n          infos: nextInfos,\n          // Show form's validity when clicking on Submit\n          valid: buildValid(nextErrors)\n        };\n        if (onValidate) onValidate(nextValidationResults);\n        validationResultsRef.current = nextValidationResults;\n        return nextValidationResults;\n      });\n\n      if (Object.keys(nextErrors).length === 0 && _onSubmit) {\n        event.persist(); // extract from React's synthetic event pool\n\n        var adjustedEvent = event;\n        adjustedEvent.value = value;\n        adjustedEvent.touched = touched;\n\n        _onSubmit(adjustedEvent);\n      }\n    }\n  }), /*#__PURE__*/React.createElement(FormContext.Provider, {\n    value: formContextValue\n  }, children));\n});\nForm.displayName = 'Form';\nForm.propTypes = FormPropTypes;\nexport { Form };"],"mappings":"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"},"metadata":{},"sourceType":"module"}